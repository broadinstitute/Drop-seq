#source ("/Users/nemesh/dropseqrna/transcriptome/R/packages/DropSeq.eqtl/R/Matrix_eQTL_CommonFunctions.R")

#library(MatrixEQTL);library (data.table);library (tictoc)

#added so R CMD CHECK succeeds.
if(getRversion() >= "2.15.1")  utils::globalVariables(c("pvalue", "min_gene_pval"))

#set the random seed for reproducibility.
set.seed(1)

#' Run adaptive permutation testing of eQTL results.
#'
#' This is a highly paramterized version of adaptive permutation that can run either best SNP/gene or gold-standard permutation testing.
#'
#' @param eQTLInputFile The non-permuted eQTL results file, generated by @see runEQTL
#' @param eQTLOutputFile The permuted output results file.
#' @param snpReportFile A file containing the best SNP for each gene where the permutation result for the gene has a better p-value than the empiric result.
#' @inheritParams runEQTL
#' @param maxNumIter how many iterations should permutation be run for.
#' @param minNumPassingPermuations how many times must the permuted value > empiric value before adaptive permutation stops testing a gene.
#' @param permutationFileName The name of the permutation file to generate (This describes how genotype columns are permuted for each permutation.)
#' @param geneList If provided, limit analysis to a subset of genes.
#' @param chromosome If provided limit analysis to a single chromosome.
#' @return The permuted results data frame.
#' @export
#' @import data.table tictoc
runAdaptivePermutationEQTL<-function (SNP_file_name, snps_location_file_name, expression_file_name, gene_location_file_name,
                                      covariates_file_name=NULL, eQTLInputFile, eQTLOutputFile, snpReportFile=NULL,
                                      useQuantileNormalization=F, minorAlleleFreqThreshold=NULL, useModel = modelLINEAR,
                                      errorCovarianceMatrixFile = NULL, maxNumIter=1e5, cisDist=100000, minNumPassingPermuations=5,
                                      permutationFileName=NULL, geneList=NULL, chromosome=NULL, snp_gene_map_file_name=NULL) {
    validateFilesExist(snps_location_file_name, SNP_file_name, expression_file_name, gene_location_file_name, covariates_file_name)

    validateSingleFileExists(snp_gene_map_file_name)
    if (is.null(snp_gene_map_file_name)) {
        snp_gene_map=NULL
    } else {
        snp_gene_map = DropSeq.utilities::fastRead(snp_gene_map_file_name, comment_regexp='^#', header = TRUE)
    }

    #read in eQTLs, pick the best SNPs, figure out how many iterations you need to run.
    eQTLs=DropSeq.utilities::fastRead(eQTLInputFile)
    bestSNPs=getBestSNPPerGene(eQTLs)
    bestSNPs$key=paste(bestSNPs$SNP, bestSNPs$gene, sep="_")

    if (!is.null(geneList)) {
        idx=which(!is.na(match(bestSNPs$gene, geneList)))
        if (length(idx)==0) cat ("No genes in genelist found.")
        bestSNPs=bestSNPs[idx,]
    }

    startOOM=2
    bestSNPs$excceds_empiric_p_snp=0L
    bestSNPs$excceds_empiric_p_gene=0L
    bestSNPs$total_permutations=0L

    snps=DropSeq.utilities::fastRead(SNP_file_name)
    snpspos = fread(snps_location_file_name, header = TRUE, stringsAsFactors = FALSE);

    #filter by chromsome the SNP and bestSNPs info.
    if (!is.null(chromosome)) {
        cat (paste("Chromosome ", chromosome, " selected, limiting set of eQTLs to permute", "\n"))
        idx=which(snpspos$chr==chromosome)
        snps=snps[idx,]
        snpspos=snpspos[idx,]
        b=intersect (snpspos$snp, bestSNPs$SNP)
        #a snp can occur in multiple genes, so you need to keep all the occurances of that SNP, not just the first.
        #bestSNPs=bestSNPs[match(b, bestSNPs$SNP),]
        idx=which(!is.na(match(bestSNPs$SNP, b)))
        bestSNPs=bestSNPs[idx,]
    }
    #special case exit early if there are no records.

    genepos = fread(gene_location_file_name, header = TRUE, stringsAsFactors = FALSE, data.table=FALSE);

    if (!is.null(snp_gene_map)) {
        snpspos = snpLocationsToPerGeneCoordinates(snpspos, snp_gene_map)
        snps = snpsToPerGeneCoordinates(snps, snp_gene_map)
        genepos = geneLocationsToPerGeneCoordinates(genepos, snp_gene_map)
        eQTLs$SNP = makePerGeneSnpName(eQTLs$SNP, eQTLs$gene)
        bestSNPs$SNP <- makePerGeneSnpName(bestSNPs$SNP, bestSNPs$gene)
    }
    #covert to data slices.
    snps=convertToSlicedData(snps)

    #get allele frequency of SNPs.
    af=getAlleleFrequency(snps)

    #convert snpspos to data frame.
    setDF(snpspos)

    #read in the expression and covariate data, which remains unchanged.
    gene=loadExpressionData(expression_file_name, useQuantileNormalization = useQuantileNormalization)
    cvrt=loadCovariates(covariates_file_name)

    errorCovariance=getErrorCovariance(errorCovarianceMatrixFile)
    errorCovariance=validateAndFilterErrorCovarianceMatrix (errorCovariance, gene)

    if (!is.null(permutationFileName)) {
        p=read.table(permutationFileName, header=F, stringsAsFactors = F, sep="\t")
        maxNumIter=dim(p)[1]
    }

    maxOrderOfMagnitude=ceiling(log10(maxNumIter))
    #run permutations in orders of magnitude.
    # always start with 2 orders of magnitude before you start excluding data.
    resultStats=vector("list", maxOrderOfMagnitude)
    tic.clearlog()

    #has the snp level report been touched yet?
    snpLevelReportHeaderWritten=F

    for (oom in startOOM:maxOrderOfMagnitude) {
        tic()
        #pick out all SNPs for genes that have not yet seen a gene-level
        #permutation result < empiric result past the stop point
        genesToTest=unique(bestSNPs[bestSNPs$excceds_empiric_p_gene<=minNumPassingPermuations,]$gene)
        #use the original eQTL results to determine which SNPs to test for these genes.
        idx=match(eQTLs$gene, genesToTest)
        idx=which(!is.na(idx))
        snpsToTest=unique(eQTLs[idx,]$SNP)

        #should I short-circuit here if there are no SNPs or genes to test?
        resultStats[[oom]]=data.frame(iterations=10^oom, num_snps=length(snpsToTest), num_genes=length(genesToTest), stringsAsFactors = F)
        if (length(snpsToTest)==0 || length(genesToTest)==0) {
            cat ("No SNPs/Genes left to test.")
            break # break out of loop if no data left to test.
        }
        #filter data to subset of genes/SNPs that should be tested.
        r1=filterSNPDataSlice(snps, snpspos, snpsToTest)
        r2=filterGeneDataSlice(gene, genepos, genesToTest, cisDist = cisDist)
        snps=r1$snps
        snpspos=r1$snpspos
        gene=r2$gene
        genepos=r2$genepos

        #how many permutations should be run?
        totalPermutationsRun=max(bestSNPs$total_permutations)
        maxPermutations=(10^oom)
        cat ("Testing SNPs [", length(snpsToTest), "] Genes [", length(genesToTest),"]\n")

        #process permutations.
        for (i in (totalPermutationsRun+1):maxPermutations) {
            permutationOrder=as.numeric(p[i,])
            cat ("Permutation [", i, "/", maxPermutations,"]\n", sep="" )
            #result<-processPermutation(snps, gene, cvrt, useModel, errorCovariance, snpspos, genepos, cisDist, bestSNPs, permutationOrder, i)
            invisible(capture.output(result<-processPermutation(snps, gene, cvrt, useModel, errorCovariance, snpspos, genepos, cisDist, bestSNPs, permutationOrder, i), type="message"))
            bestSNPs=result$bestSNPs
            resultsExceedingPermutation=result$resultsExceedingPermutation
            #filter snps that exceed permutation to SNPs that have an original FDR that's interesting by matrix eQTL standards.
            #resultsExceedingPermutation=resultsExceedingPermutation[resultsExceedingPermutation$original_FDR<=0.05,]
            #write out these results if any.
            if (!is.null(resultsExceedingPermutation) & !is.null(snpReportFile)) {
                writeSNPReportFile(resultsExceedingPermutation, snpReportFile, writeHeader=!snpLevelReportHeaderWritten,
                                   undoPerGene=!is.null(snp_gene_map))
                snpLevelReportHeaderWritten=T
            }
        }

        bestSNPs$snp_permuted_pvalue=(bestSNPs$excceds_empiric_p_snp+1)/(bestSNPs$total_permutations+1)
        bestSNPs$gene_permuted_pvalue=(bestSNPs$excceds_empiric_p_gene+1)/(bestSNPs$total_permutations+1)
        z=toc(log = TRUE, quiet = TRUE)
    }
    #final write
    bestSNPs[,key:=NULL]

    #if there were no genes to test on a chromosome, then there are missing columns that need to be fixed here.
    if (dim(bestSNPs)[1]==0) {
        df2=data.frame(snp_permuted_pvalue=numeric(), gene_permuted_pvalue=numeric(), original_pvalue=numeric())
        bestSNPs=cbind(bestSNPs, df2)
    }
    if (!is.null(snp_gene_map)) {
        bestSNPs$SNP = undoPerGeneSnpName(bestSNPs$SNP)
    }
    writeeQTLOutputFile(bestSNPs, eQTLOutputFile)
    resultStats=do.call(rbind, resultStats)
    #if you didn't run all of the orders of magnitude you need to pre-filter before you bind.
    resultStats=resultStats[resultStats$num_genes>0,]
    timings=do.call(rbind, tic.log(format=T))
    resultStats$timing=timings[,1]
    print (resultStats)
    return (bestSNPs)
}

writeSNPReportFile<-function (resultsExceedingPermutation, snpReportFile, writeHeader=T, undoPerGene=FALSE) {
    resultsExceedingPermutation$statistic=round(resultsExceedingPermutation$statistic, 5)
    resultsExceedingPermutation$original_pvalue=format(resultsExceedingPermutation$original_pvalue, scientific=T, digits=5)
    resultsExceedingPermutation$pvalue=format(resultsExceedingPermutation$pvalue, scientific=T, digits=5)
    resultsExceedingPermutation$beta=round(resultsExceedingPermutation$beta, 5)
    if (undoPerGene) {
        resultsExceedingPermutation$snps = undoPerGeneSnpName(as.character(resultsExceedingPermutation$snps))
        resultsExceedingPermutation$original_snp = undoPerGeneSnpName(resultsExceedingPermutation$original_snp)
    }
    write.table(resultsExceedingPermutation, snpReportFile, row.names=F, col.names=writeHeader, quote=F, sep="\t", append=!writeHeader)
}

writeeQTLOutputFile<-function (bestSNPs, eQTLOutputFile) {
    bestSNPs$`t-stat`=round(bestSNPs$`t-stat`, 5)
    bestSNPs$beta=round(bestSNPs$beta, 5)
    bestSNPs$r2=round(bestSNPs$r2, 5)
    bestSNPs$beta_se=round(bestSNPs$beta_se, 5)
    bestSNPs$MAF=round(bestSNPs$MAF, 5)
    bestSNPs$effect_size=round(bestSNPs$effect_size, 5)
    bestSNPs$original_pvalue=format(bestSNPs$original_pvalue, scientific=T, digits=5)
    bestSNPs$snp_permuted_pvalue=format(bestSNPs$snp_permuted_pvalue, scientific=T, digits=5)
    write.table(bestSNPs, eQTLOutputFile, row.names=F, col.names = T, quote=F, sep="\t")
}



#' Multi-step permutation analysis
#'
#' In the full permutation test, ALL snps for a gene are have their genotypes permuted, and for each SNP it's empiric pvalue is compared
#' to ALL SNPs for the gene.
#' @inheritParams runEQTLFromBaseFileNames
#' @inheritParams runAdaptivePermutationEQTL
#' @param eQTLInputFile The empiric pvalues, as generated by runEQTL.
#' @param eQTLOutputFullPermutationFile The results after running second round full permutation (ALL snps per gene).
#' @param snpReportFile Output a report of SNPs that surpase the empiric pvalues during permutation.
#' @param generatePermutations If true, a new permutation file is generated.  If false, the existing one is used.  If false and the file does not exist, throws an error.
#' @return The permuted results data frame.
#' @export
runAdaptiveMultiStepPermutations<-function (snps_location_file_name, SNP_file_name, expression_file_name,
                                            gene_location_file_name, covariates_file_name=NULL, eQTLInputFile, permutationFileName,
                                            eQTLOutputFullPermutationFile, snpReportFile, maxNumIter=1000, cisDist=100000,
                                            minNumPassingPermuations=5, useModel = modelLINEAR,
                                            minorAlleleFreqThreshold=NULL, useQuantileNormalization=F,
                                            errorCovarianceMatrixFile = NULL, chromosome=NULL, generatePermutations=T,
                                            snp_gene_map_file_name=NULL) {

    if (generatePermutations) {
        generatePermutationOrderFile(numPermuations=maxNumIter, expressionFileName=expression_file_name, permutationOrderFileName=permutationFileName)
    } else {
        if (file.exists(permutationFileName)==F) stop("Permutation file wasn't supposed to be generated, but doesn't exist. Exiting.")
    }

    bestGenes=c()
    #TODO: REMOVE DEBUG CODE
    #bestGenes=c("CCNDBP1")
    #debug (runAdaptivePermutationEQTL)
    bestSNPs=runAdaptivePermutationEQTL (SNP_file_name, snps_location_file_name, expression_file_name,
                                         gene_location_file_name, covariates_file_name, eQTLInputFile,
                                         eQTLOutputFullPermutationFile, snpReportFile,
                                         useQuantileNormalization=useQuantileNormalization,
                                         minorAlleleFreqThreshold=minorAlleleFreqThreshold,
                                         useModel = useModel, errorCovarianceMatrixFile = errorCovarianceMatrixFile, maxNumIter=maxNumIter,
                                         cisDist=cisDist, minNumPassingPermuations=minNumPassingPermuations,
                                         permutationFileName=permutationFileName, geneList=bestGenes, chromosome=chromosome,
                                         snp_gene_map_file_name=snp_gene_map_file_name)

    return (bestSNPs)
}

#full multi-step permutation analysis
#run permutation on best SNPs <X> times to get a list of genes to look at.
#run permuations on ALL SNPs <Y> times (where Y > X, but uses the same permutation ordering) to assess each SNP in a gene using the "gold standard" permuation testing.

#' Multi-step permutation analysis
#'
#' @inheritParams runAdaptiveMultiStepPermutations
#' @param base.dir The directory data resides in.
#' @param base.name The prefix of all files for this data set.
#' @param output.dir The directory where output files should be emitted
#' @param generatePermutations should a new set of permutations be used, or should existing permutation files be used.
#' @return The results of adaptive permutation (ALL SNPs per gene.)
#'
#' @export
runAdaptiveMultiStepPermutationsFromBaseFileNames<-function (base.dir, base.name, output.dir=base.dir, maxNumIter=1000, cisDist=100000, minNumPassingPermuations=5, useModel = modelLINEAR,
                                                    minorAlleleFreqThreshold=NULL, useQuantileNormalization=F, errorCovarianceMatrixFile = NULL,
                                                    chromosome=NULL, generatePermutations=T) {

    # Genotype file name
    snps_location_file_name = getSNPLocationFileName(base.dir, base.name)
    SNP_file_name= getSNPFileName(base.dir, base.name)

    # Gene expression file name
    expression_file_name = getExpressionFileName(base.dir, base.name)
    gene_location_file_name = getGeneLocationFileName(base.dir, base.name)

    # Covariates file name
    covariates_file_name = getCovariateFileName(base.dir, base.name)
    # Output file name
    eQTLInputFile=getOutCiseQTLFileName(base.dir, base.name, useQuantileNormalization, cisDist)

    # Error covariance matrix
    eQTLOutputFullPermutationFile=getFullPermutationFileName(base.dir, base.name, output.dir, chromosome, useQuantileNormalization, cisDist)
    permutationFileName=getPermutationOrderFileName(base.dir, base.name, output.dir, chromosome, useQuantileNormalization, cisDist)
    snpReportFile=getSNPLevelReportFile(base.dir, base.name, output.dir, chromosome, useQuantileNormalization, cisDist)

    #debug(runAdaptivePermutationEQTL)
    resultStats=runAdaptiveMultiStepPermutations(snps_location_file_name, SNP_file_name, expression_file_name, gene_location_file_name, covariates_file_name,
                                                eQTLInputFile, permutationFileName, eQTLOutputFullPermutationFile, snpReportFile,
                                                maxNumIter, cisDist, minNumPassingPermuations, useModel, minorAlleleFreqThreshold, useQuantileNormalization,
                                                errorCovarianceMatrixFile, chromosome, generatePermutations)

    return (resultStats)

}

#for each gene, pick the SNP that had the best original result, and calculate it's gold standard pvalue (the number of times any SNP in that gene had a pvalue stronger than it.)
getGeneSummary<-function (bestSNPs) {
    result=getBestSNPPerGene(bestSNPs)
    result$gold_standard_pvalue=result$excceds_empiric_p_gene/result$total_permutations
    #plot (log10(result$FDR), log10(result$gold_standard_pvalue))

}

#filter the snps and snpspos data to the list of best SNPs, and maintain order.
#if there are no overlapping bestSNPIDs, then I need to do somethig...but not sure what.
filterSNPDataSlice<-function (snps, snpspos, bestSNPIDs) {
    idx=which(!is.na(match(snps$GetAllRowNames(), bestSNPIDs)))
    snps$RowReorder(idx)
    idx=which(!is.na(match(snpspos$snp, bestSNPIDs)))
    snpspos=snpspos[idx,]
    result=list(snps=snps, snpspos=snpspos)
    return (result)
}

filterGeneDataSlice<-function (gene, genepos, bestGeneIDs, cisDist=NULL) {
    idx=which(!is.na(match(gene$GetAllRowNames(), bestGeneIDs)))
    gene$RowReorder(idx)
    idx=which(!is.na(match(genepos$geneid, bestGeneIDs)))
    genepos=genepos[idx,]

    #cheat and reorder genes?
    #only sort if there's something to sort.
    if (!is.null(cisDist) & length(idx)>0) {
        r=jankAssSortGenes(gene, genepos, cisDist)
        gene=r$gene
        genepos=r$genepos
    }

    result=list(gene=gene, genepos=genepos)
    return (result)
}

getBestSNPPerGene<-function (eQTLs) {
    #get the best SNP for each eQTL
    getBestSNP<-function (x) {
        return (x[which.min(x$`p-value`),])
    }
    bestSNPs=eQTLs[,getBestSNP(.SD),by="gene"]

    bestSNPs$key=paste(bestSNPs$SNP, bestSNPs$gene, sep="_")
    return (bestSNPs)
}

# bestSNPs is the output from the empiric eQTL run, with an additional column "key", which is: SNPID_GENEID
processPermutation<-function (snps, gene, cvrt, useModel, errorCovariance, snpspos, genepos, cisDist, bestSNPs, permutationOrder=NULL, permutationIteration) {
    #is it possible the snps are staying permuted once we're out of the function?
    #Yup.  PITA.  Need to "put them back" into the original ordering again.  Le-sigh.
    originalColNames=colnames(snps)

    if (is.null(permutationOrder)) {
        permutationOrder=sample (1:snps$nCols())
        snps$ColumnSubsample(sample (1:snps$nCols()))
    } else {
        snps$ColumnSubsample(permutationOrder)
    }
    invisible(capture.output(result<- Matrix_eQTL_main(
        snps = snps,
        gene = gene,
        cvrt = cvrt,
        output_file_name     = NULL,
        pvOutputThreshold     = 0,
        useModel = useModel,
        errorCovariance = errorCovariance,
        verbose = FALSE,
        output_file_name.cis = NULL,
        pvOutputThreshold.cis = 1,
        snpspos = filterSNPsPosForMatrix_eQTL(snpspos),
        genepos = genepos,
        cisDist = cisDist,
        pvalue.hist = "qqplot",
        min.pv.by.genesnp = T,
        noFDRsaveMemory = FALSE)))

    #put the SNP back into the original column ordering
    idx=match(originalColNames, colnames(snps))
    snps$ColumnSubsample(idx)

    #order the new eQTLs in the same order as the known best results, then count times the permuted result exceeds the old
    newEQTLs=result$cis$eqtls
    setDT(newEQTLs, key="gene")
    FDR=NULL; #R CMD CHECK
    newEQTLs[, FDR:=NULL]
    #what's the best result for each gene?  This is the minimum pvalue for the gene in the permutation
    #in case of ties, order by the SNPs alphanumeric name
    getBestSNP<-function (x) {
        m=min(x$`pvalue`)
        xx=x[x$`pvalue`<=m,]
        xx=xx[order(xx$snps),]
        return (xx[1,])
        #return (x[which.min(x$`pvalue`),])
    }
    perGenePermutatioNResult=newEQTLs[,getBestSNP(.SD),by="gene"]

    #map on the gene-level permutation results
    #indexes that are not null are new result genes that are in the original results.
    idxPerGene=match(bestSNPs$gene, perGenePermutatioNResult$gene)
    idxNotNA=which(!is.na(idxPerGene))

    if (length(which(perGenePermutatioNResult[idxPerGene[idxNotNA]]$gene!=bestSNPs[idxNotNA,]$gene)>0)) {
        stop ("Results out of frame for best result per gene vs eQTL original result")
    }
    #add total permutations
    bestSNPs[idxNotNA,]$total_permutations=as.integer(bestSNPs[idxNotNA,]$total_permutations+1)

    #add gene level results
    idxExceedsEmpiricPvalueGene=which(perGenePermutatioNResult[idxPerGene[idxNotNA],]$pvalue<bestSNPs[idxNotNA,]$`p-value`)

    resultsExceedingPermutation=c()
    if (length(idxExceedsEmpiricPvalueGene)>0) {
        bestSNPs[idxNotNA[idxExceedsEmpiricPvalueGene],]$excceds_empiric_p_gene=as.integer(bestSNPs[idxNotNA[idxExceedsEmpiricPvalueGene],]$excceds_empiric_p_gene+1)
        resultsExceedingPermutation=perGenePermutatioNResult[idxPerGene[idxNotNA[idxExceedsEmpiricPvalueGene]],]
        original=bestSNPs[idxNotNA[idxExceedsEmpiricPvalueGene],]
        resultsExceedingPermutation$original_gene=original$gene
        resultsExceedingPermutation$original_snp=original$SNP
        resultsExceedingPermutation$original_pvalue=original$`p-value`
        resultsExceedingPermutation$permutation_iter=permutationIteration
        #if (any(resultsExceedingPermutation$original_gene!=resultsExceedingPermutation$gene))
        #    browser()
    }

    #both the gene level exceeds the value and the SNP matches.
    idxExceedsEmpiricPvalueSNP=which(perGenePermutatioNResult[idxPerGene[idxNotNA],]$pvalue<bestSNPs[idxNotNA,]$`p-value` & perGenePermutatioNResult[idxPerGene[idxNotNA],]$snps==bestSNPs[idxNotNA,]$SNP)
    if (length(idxExceedsEmpiricPvalueSNP)>0) {
        bestSNPs[idxNotNA[idxExceedsEmpiricPvalueSNP],]$excceds_empiric_p_snp=as.integer(bestSNPs[idxNotNA[idxExceedsEmpiricPvalueSNP],]$excceds_empiric_p_snp+1)
    }

    resultList=list(bestSNPs=bestSNPs, resultsExceedingPermutation=resultsExceedingPermutation)
    return (resultList)
}


#' Replicate matrix eQTL sorting by position.
#'
#' To avoid sorting data on every permutation iteration, sort the data in the strange way expected by matrix eQTL.
#' This feels a bit hacky, but does prevent sorting AND speeds up analysis.
#'
#' @param gene A matrix of geneotypes
#' @param genepos A matrix of SNP locations.
#' @param cisDist The distance eQTL will search around each gene for SNPs.
#'
#' @return a list containing a sorted version of the gene and genepos objects handed in.
jankAssSortGenes<-function (gene, genepos, cisDist) {
    if (dim(genepos)[1]==0) return (list(gene=gene, genepos=genepos))
    gene_names=genepos$geneid
    genematch = match(gene_names, genepos[, 1], nomatch = 0L)
    chrNames = unique(as.character(unique(genepos[,2])))
    chrNames = chrNames[sort.list(suppressWarnings(as.integer(chrNames)),
                                  method = "radix", na.last = TRUE)]
    genechr = match(genepos[, 2], chrNames)
    chrMax = max(genepos[, 4], na.rm = TRUE) + cisDist
    genepos2 = as.matrix(genepos[, 3:4, drop = FALSE] + (genechr - 1) * chrMax)
    gene_pos = matrix(0, length(gene_names), 2)
    gene_pos[genematch > 0, ] = genepos2[genematch, , drop = FALSE]
    gene_pos[rowSums(is.na(gene_pos)) > 0, ] = 0
    gene_pos[gene_pos == 0] = (length(chrNames) + 2) * (chrMax + cisDist)
    if (is.unsorted(rowSums(gene_pos))) {
        cat("Reordering genes\n")
        ordr = sort.list(rowSums(gene_pos))
        gene$RowReorder(ordr)
        rm(ordr)
    }

    #fix up the genepos to match gene.
    idx=match(gene$GetAllRowNames(), genepos$geneid)
    genepos=genepos[idx,]
    if (length(which(genepos$geneid!=gene$GetAllRowNames()))) cat ("problems sorting genes and positions...")
    result=list(gene=gene, genepos=genepos)
    return (result)
}

#####################################################
#NOT USED ANYMORE
######################################################


# runAdaptivePermutationsFromBaseFileNames<-function (base.dir, base.name, maxNumIter=1000, cisDist=100000, useModel = modelLINEAR,
#                                                     minorAlleleFreqThreshold=NULL, useQuantileNormalization=F, errorCovariance = numeric(), fdrThreshold=NULL, generatePermutations=F, chromosome=NULL) {
#     # Genotype file name
#     snps_location_file_name = getSNPLocationFileName(base.dir, base.name)
#     SNP_file_name= getSNPFileName(base.dir, base.name)
#
#     # Gene expression file name
#     expression_file_name = getExpressionFileName(base.dir, base.name)
#     gene_location_file_name = getGeneLocationFileName(base.dir, base.name)
#
#     # Covariates file name
#     covariates_file_name = getCovariateFileName(base.dir, base.name)
#     # Output file name
#     output_file_name_cis=getOutCiseQTLFileName(base.dir, base.name, useQuantileNormalization, cisDist)
#
#     # Error covariance matrix
#     # Set to numeric() for identity.
#     errorCovariance = numeric();
#
#     eQTLInputFile=output_file_name_cis
#     eQTLOutputFile=paste(eQTLInputFile, ".permuted.txt", sep="")
#     permutationFileName=getPermutationOrderFileName(base.dir, base.name)
#     if (generatePermutations) {
#         if (file.exists(expression_file_name)==F) stop (paste("Expression file does not exist: ", expression_file_name))
#         generatePermutationOrderFile(numPermuations=maxNumIter, expressionFileName=expression_file_name, permutationOrderFileName=permutationFileName)
#     } else {
#         if (file.exists(permutationFileName)==F) stop("Permutation file doesn't exit, but was not requested to be generated.  Exiting.")
#     }
#
#     bestSNPs=runAdaptivePermutationEQTL (SNP_file_name, snps_location_file_name, expression_file_name, gene_location_file_name, covariates_file_name, eQTLInputFile,
#                                          eQTLOutputFile, useQuantileNormalization=useQuantileNormalization, minorAlleleFreqThreshold=minorAlleleFreqThreshold,
#                                          useModel = useModel, errorCovariance = errorCovariance, maxNumIter=maxNumIter, cisDist=cisDist,
#                                          permutationFileName=permutationFileName, chromosome=chromosome)
#
#
#
#     return (bestSNPs)
# }


#run with mostly default args.
#runPermutationsFromAssumedFileNames(base.dir, base.name, numIter=1000, fdrThreshold=0.05)

#' Run basic permutation testing on eQTL data.
#'
#' This runs permutation testing (either best SNP/Gene or all SNPs per gene) permutation testing on a set of empiric results
#' This relies on file naming conventions to generate input/output files.
#'
#' @param base.dir The directory data resides in.
#' @param base.name The prefix of all files for this data set.
#' @param numIter
#' @param cisDist
#' @param useModel
#' @param minorAlleleFreqThreshold
#' @param useQuantileNormalization
#' @param errorCovariance
#' @param fdrThreshold
# runPermutationsFromBaseFileNames<-function (base.dir, base.name, numIter=1000, cisDist=100000, useModel = modelLINEAR,
#                                             minorAlleleFreqThreshold=NULL, useQuantileNormalization=F, errorCovariance = numeric(), fdrThreshold=NULL) {
#     # Genotype file name
#     snps_location_file_name = getSNPLocationFileName(base.dir, base.name)
#     SNP_file_name= getSNPFileName(base.dir, base.name)
#
#     # Gene expression file name
#     expression_file_name = getExpressionFileName(base.dir, base.name)
#     gene_location_file_name = getGeneLocationFileName(base.dir, base.name)
#
#     # Covariates file name
#     covariates_file_name = getCovariateFileName(base.dir, base.name)
#     # Output file name
#     output_file_name_cis=getOutCiseQTLFileName(base.dir, base.name, useQuantileNormalization)
#
#     # Error covariance matrix
#     # Set to numeric() for identity.
#     errorCovariance = numeric();
#     # errorCovariance = read.table("Sample_Data/errorCovariance.txt");
#
#     eQTLInputFile=output_file_name_cis
#     eQTLOutputFile=paste(eQTLInputFile, ".permuted.txt", sep="")
#     runPermutationEQTL (SNP_file_name, snps_location_file_name, expression_file_name, gene_location_file_name, covariates_file_name, eQTLInputFile,
#                         eQTLOutputFile, useQuantileNormalization=useQuantileNormalization, minorAlleleFreqThreshold=minorAlleleFreqThreshold,
#                         useModel = useModel, errorCovariance = errorCovariance, numIter=numIter, fdrThreshold=fdrThreshold, cisDist=cisDist)
# }
#
# #system.time(runPermutationEQTL(SNP_file_name, snps_location_file_name, expression_file_name, gene_location_file_name, covariates_file_name, eQTLInputFile, eQTLOutputFile, useQuantileNormalization=F, minorAlleleFreqThreshold=NULL, useModel = modelLINEAR, errorCovariance = numeric(), numIter=100, fdrThreshold=0.05))
# runPermutationEQTL<-function (SNP_file_name, snps_location_file_name, expression_file_name, gene_location_file_name, covariates_file_name, eQTLInputFile, eQTLOutputFile, useQuantileNormalization=F, minorAlleleFreqThreshold=NULL, useModel = modelLINEAR, errorCovariance = numeric(), numIter=100, fdrThreshold=NULL, cisDist=100000) {
#     validateFilesExist(snps_location_file_name, SNP_file_name, expression_file_name, gene_location_file_name, covariates_file_name)
#     snps=fread(SNP_file_name)
#     snpspos = fread(snps_location_file_name, header = TRUE, stringsAsFactors = FALSE);
#
#     eQTLs=fread(eQTLInputFile)
#     bestSNPs=getBestSNPPerGene(eQTLs, fdrThreshold)
#
#     bestSNPIDs=unique(bestSNPs$SNP)
#     bestGeneIDs=unique(bestSNPs$gene)
#
#     #covert to data slices.
#     snps=convertToSlicedData(snps)
#
#     #convert snpspos to data frame.
#     setDF(snpspos)
#
#     #read in the expression and covariate data, which remains unchanged.
#     genepos = fread(gene_location_file_name, header = TRUE, stringsAsFactors = FALSE, data.table=FALSE);
#     gene=loadExpressionData(expression_file_name, useQuantileNormalization = useQuantileNormalization)
#     cvrt=loadCovariates(covariates_file_name)
#
#     #filter genes and SNPs
#     r1=filterSNPDataSlice(snps, snpspos, bestSNPIDs)
#     r2=filterGeneDataSlice(gene, genepos, bestGeneIDs, cisDist = cisDist)
#     snps=r1$snps
#     snpspos=r1$snpspos
#     gene=r2$gene
#     genepos=r2$genepos
#
#     #add a column to the results for the number of times each a permutation exceeds the empiric pvalue.
#     bestSNPs$excceds_empiric_p=0
#
#     #to permutate the data:
#     #
#     for (i in 1:numIter) {
#
#         cat ("Permutation [", i, "/", numIter,"]\n", sep="" )
#         bestSNPs=processPermutation(snps, gene, cvrt, useModel, errorCovariance, snpspos, genepos, cisDist, bestSNPs)
#     }
#
#     af=getAlleleFrequency(snps)
#     idx=match(bestSNPs$SNP, names(af))
#     bestSNPs$maf=af[idx]
#
#     bestSNPs$total_permutations=numIter
#     write.table(bestSNPs, eQTLOutputFile, row.names=F, col.names = T, quote=F, sep="\t")
#
# }
