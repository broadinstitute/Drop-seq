#aggregate a set of eQTL permutation results that span a list of files.
#library (qvalue)
#library (data.table)

#inFileList=list.files("/downloads/eQTL_Parameter_Test/maf_0.2.window_10000/per_chromosome", pattern="full_permuted.chr", full.names=T)
#outFile="/downloads/eQTL_Parameter_Test/maf_0.20.window_10000.eQTL_results.full_permuted.txt"
#combinePermutationResults(inFileList, outFile)
#outIndexSNPsFile="/downloads/eQTL/villageC/out_nextseq_novaseq/DropulationVillageC_all.eQTL_results_100kb.txt.full_permuted.indexSNPs.txt"


#empiricResultsFile="/downloads/eQTL/villageC/out_nextseq_novaseq/DropulationVillageC_all.eQTL_results_100kb.txt"

#' Combine permutation results from runAdaptivePermutationEQTL.
#'
#' Merges results across the per-chromosome files into a single output file, then sorts the data in genomic order
#' and adds a q-value calculation to be select the final set of results.
#' @param inFileList A list of eQTL permutation result files to combine.
#' @param outFile The single file to emit with permutation results across all chromosomes and FDR correction.
#' @param sequenceDictionaryFile A file containing the ordering of chromosomes in the reference.  If not set, do not sort output file.
#' @import qvalue data.table
#' @export
combinePermutationResults<-function (inFileList, outFile, sequenceDictionaryFile=NULL) {
    if (length(inFileList)==0) stop("Input file list empty!")
    r=lapply(inFileList, readFile)
    #before output, it would be nice to sort in chromosome order.
    #change chrX to 23 and Y to 24.
    result=do.call(rbind, r)
    #result=sortByChromosomePos(result)
    if (!is.null(sequenceDictionaryFile)) {
        result = sortByChromosomePosSequenceDictionary(result, sequenceDictionaryFile)
    }
    #correct by q-value
    p=qvalue (result$gene_permuted_pvalue, fdr.level=0.05,pi0.method="smoother")
    result$qvalue=p$qvalues

    cat ("Number of eQTLs with qvalue <=0.05", dim (result[result$qvalue<=0.05,])[1], "\n")
    write.table(result, outFile, row.names=F, col.names=T, quote=F, sep="\t")
}

#' Sort the permuted output data frame by SNP chromosome and position ordering
#'
#' Uses a sequence dictionary file (see Picard's CreateSequenceDictionary) to determine the order of
#' chromosomes in the output.
#'
#' @param result The permuted results per chromosome bound into a single data frame.  This must contain a SNP
#' column that is formatted as chromosome:position:ref_allele:alt_allele.
#' @param sdFile A file detailing the expected order of chromosomes to perserve genomic ordering for
#' the reference, generated by Picard's CreateSequenceDictionary.
#' @return The input data frame, sorted in genomic order.
sortByChromosomePosSequenceDictionary<-function (result, sdFile) {
    s=strsplit (result$SNP, ":")
    chr=sapply(s, function (x)x[1])
    pos=as.numeric (sapply(s, function (x)x[2]))
    #look up the chromosome in the sequence dictionary and use that index for ordering.
    sd=read.table(sdFile, skip = 1, stringsAsFactors = F)
    sd$V2=sub("SN:", "", sd$V2)
    idxChr=match(chr, sd$V2)
    #order by chromosome, position, gene permuted pvalue.
    idx=order(idxChr, pos, result$gene_permuted_pvalue)
    result=result[idx,]
    return (result)
}


#' Read in a eQTL permutation result file.
#'
#' @param x A single chromosome permutation result file.
#'
#' @return A data table containing the single chromosome permutation results.
#' An attribute gene_count is added that has the total number of genes tested.
readFile<-function (x) {
    #get the number of genes.
    #if this header isn't set, set it to the unique number of genes in the data set.
    a=read.table(x, nrows=1, comment.char="@", stringsAsFactors = F)$V1
    nGenes=as.numeric (strsplit (a, "=", fixed=T)[[1]][2])
    a=suppressWarnings(fread(x))
    attr (a, "gene_count")=nGenes
    return (a)
}

#' Combine permutation results.
#'
#' @param inDir The directory in which the per-chromosome permutation results are located
#' @param pattern The string prefix or suffix to filter file names by to get just the permutation result files.
#' @param outFile The single file to emit with permutation results across all chromosomes and FDR correction.
#'
#' @export

combinePermutationResultsFromBaseNames<-function (inDir, pattern="eQTL_results.full_permuted", outFile) {
    inFileList=list.files(inDir, pattern, full.names=T)
    combinePermutationResults(inFileList, outFile)
}


#' Experiments with q-value correction vs BH FDR and Bonferroni.  DON'T USE.
#'
#' @param result The eQTL data set.
#' @import graphics
# correctByQValueExperimental<-function (result) {
#     p=qvalue (result$gene_permuted_pvalue, fdr.level=0.05,pi0.method="smoother")
#     result$qvalue=p$qvalues
#     return (result)
#
#     summary (p)
#     plot (p)
#     hist (p)
#
#     #How do the various FDR methods compare.
#     #it's not like a single p-value survives bonferroni.
#     length(which(p.adjust (result$gene_permuted_pvalue, method="bonferroni")<0.05))
#     bonferroniThreshold=0.05/dim(result)[1]
#     pBH=p.adjust (result$gene_permuted_pvalue, method="fdr")
#     num_BH_FDR=length(which(pBH<=0.05))
#     format(max(result[pBH<=0.05,]$gene_permuted_pvalue), scientific=T, digits=4)
#     format(max(result[result$qvalue<=0.05,]$gene_permuted_pvalue), scientific=T, digits=4)
#
#     idx=which(result$qvalue<=0.05)
#     h=hist (-log10(result$gene_permuted_pvalue), breaks=25, main="original data [-log10]", xlab="Permuted p-value")
#     #hist(-log10(result[idx,]$best_snp_permuted_pvalue), breaks=h$breaks, col="blue", add=T)
#     h=hist (result$gene_permuted_pvalue, breaks=25, main="Permuted Gene P-values", xlab="Permuted p-value", cex.lab=1.25, cex.axis=1.25)
#     #abline(v=-log10(max(r[idx,]$best_full_permuted_pvalue)), col="blue")
#
#     m=median (h$counts)
#     abline (h=m, col="red")
#     getIdxToRemove<-function (pStart=0.05, pEnd=0.1, r, m) {
#         idx=which(r$best_full_permuted_pvalue>pStart & r$best_full_permuted_pvalue<pEnd)
#         num=length(idx)-m
#         idx=sample (idx, num)
#         r=r[-idx,]
#         return (r)
#     }
#     r=result
#     rClean=getIdxToRemove(0.05, 0.1, r, m)
#     rClean=getIdxToRemove(0.1, 0.15, rClean, m)
#     rClean=getIdxToRemove(0.15, 0.2, rClean, m)
#     rClean=getIdxToRemove(0.2, 0.25, rClean, m)
#     rClean=getIdxToRemove(0.25, 0.3, rClean, m)
#     rClean=getIdxToRemove(0.3, 0.35, rClean, m)
#     rClean=getIdxToRemove(0.35, 0.4, rClean, m)
#     rClean=getIdxToRemove(0.4, 0.45, rClean, m)
#     rClean=getIdxToRemove(0.45, 0.5, rClean, m)
#     h=hist (rClean$best_full_permuted_pvalue, breaks=25, main="artificially cleaned data", xlab="Permuted p-value")
#
#     pClean=qvalue (rClean$best_full_permuted_pvalue, fdr.level=0.05,pi0.method="smoother")
#     summary (pClean)
#     plot (pClean)
#     h=hist (pClean)
#     rClean$best_full_permuted_qvalue=pClean$qvalues
#
#     max(rClean[rClean$best_full_permuted_qvalue<=0.05,]$best_full_permuted_pvalue)
#
#     plot (-log10(r$best_full_permuted_pvalue), -log10(r$best_full_permuted_qvalue), xlab="permuted pvalue [log10]", ylab="q-value [log10]")
#     abline (h=-log10(0.05), col="red")
#     abline (v=-log10(0.05), col="blue")
#
#     z=r[r$FDR<=0.05,]
#     plot (z$FDR, z$best_full_permuted_qvalue, xlab="Matrix eQTL FDR", ylab="qvalue of permuted SNPs")
#     zz=z[z$FDR<0.05 & z$best_full_permuted_qvalue>0.05,]
#
#
#     return (r)
#     #plot (r$FDR, r$best_full_permuted_pvalue, xlab="matrix eQTL FDR", ylab="permuted p-value")
#     #plot (r$FDR, r$best_full_permuted_pvalue_FDR, xlab="matrix eQTL FDR", ylab="permutation FDR")
#     #plot (r$best_full_permuted_pvalue, r$best_full_permuted_pvalue_FDR, xlab="permuted p-value", ylab="permutation FDR")
# }

# getBestSNPPerGene<-function (result, pvalColumn="p.value") {
#     #get the best SNP for each eQTL
#     getBestSNP<-function (x) {
#         return (x[which.min(x[[pvalColumn]]),])
#     }
#     bestSNPs=result[,getBestSNP(.SD),by="gene"]
#     return (bestSNPs)
# }


# sortByChromosomePos<-function (result) {
#     chr[chr=="X"]<-"23"
#     chr[chr=="Y"]<-"24"
#     chr[chr=="MT"]<-"25"
#     idx=order(chr, pos)
#     result=result[idx,]
#     return (result)
# }







#compare the best gene selection permutation to the gold standard permutation

# comparePermutedResults<-function () {
#     a=fread("/downloads/eQTL/villageC/out_novaseq_1/DropulationVillageC_09-07-2017massamp.eQTL_results_100kb.txt.permuted.txt")
#     b=fread("/downloads/eQTL/villageC/out_novaseq_1/DropulationVillageC_09-07-2017massamp.eQTL_results_100kb.txt.full_permuted.txt")
#
#     #need to match on SNP+Gene
#     a$key=paste(a$SNP, ":", a$gene, sep="")
#     b$key=paste(b$SNP, ":", b$gene, sep="")
#
#     #not all genes originally tested in A are present in B.  Those genes have pvalues > the threshold.
#     missingResults=a[which(is.na(match(a$key, b$key))),]
#     #this value will be > the firstPassPvalueThreshold value.
#     minPvalueMissingGenes=min(a[match(missingResults, a$gene),]$`p-value`)
#
#     #only use the overlap...
#     overlap=intersect (a$key, b$key)
#     a=a[match(overlap, a$key),]
#
#     idx=match(a$key, b$key)
#     b=b[idx,]
#
#     #compare the ones that have the same number of permutations.
#     idx=which(a$total_permutations==b$total_permutations)
#     aa=a[idx,]
#     bb=b[idx,]
#     #this should be 0 results, and is.
#     which(aa$excceds_empiric_p!=bb$excceds_empiric_p)
# }
#
# compareGeneListsByIntersection<-function () {
#     a=read.table("/downloads/eQTL_Parameter_Test/maf_0.05.window_10000.eQTL_results.full_permuted.txt", header=T, stringsAsFactors = F)
#     b=read.table("/downloads/eQTL_Parameter_Test/maf_0.05.window_100000.eQTL_results.full_permuted.txt", header=T, stringsAsFactors = F)
#     a=a[a$qvalue<=0.05,]
#     b=b[b$qvalue<=0.05,]
#
# }

